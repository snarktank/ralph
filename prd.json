{
  "branchName": "feature/error-recovery-system",
  "description": "Robust error handling, checkpoint/resume, and graceful degradation system for Ralph to handle API rate limits, usage quotas, timeouts, and stalled executions",
  "project": "Ralph",
  "userStories": [
    {
      "acceptanceCriteria": [
        "Create src/error/mod.rs with module exports",
        "Create src/error/classification.rs with ErrorCategory enum (Transient, UsageLimit, Fatal, Timeout)",
        "Define TransientReason, UsageLimitReason, FatalReason, TimeoutReason sub-enums",
        "Define RecoveryHint enum (RetryNow, RetryAfter, WaitForUser, StopExecution, ResumeFromCheckpoint)",
        "Define ClassifiedError struct with category, message, recovery_hint, context",
        "Add pub mod error; to src/lib.rs",
        "Unit tests for classification types",
        "Typecheck passes"
      ],
      "description": "As a developer, I need error classification types to categorize errors into actionable recovery strategies.",
      "id": "US-001",
      "notes": "Foundation module - other recovery features depend on this",
      "passes": true,
      "priority": 1,
      "title": "Error classification types and module structure"
    },
    {
      "acceptanceCriteria": [
        "Create src/error/detector.rs",
        "Define ErrorPattern struct with regex pattern, category, recovery_hint",
        "Define ErrorDetector with pre-configured patterns for Claude Code errors",
        "Detect rate limit patterns: '429', 'rate limit', 'too many requests'",
        "Detect usage limit patterns: 'plan limit', 'usage limit', 'quota exceeded'",
        "Detect auth errors: 'unauthorized', 'authentication failed', 'invalid token'",
        "Implement classify_error() that returns ClassifiedError from text",
        "Implement classify_exit_code() for timeout detection",
        "Unit tests for all pattern matching scenarios",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need to detect and classify errors from agent output using pattern matching.",
      "id": "US-002",
      "notes": "Uses case-insensitive regex matching",
      "passes": true,
      "priority": 2,
      "title": "Error pattern detector for Claude Code errors"
    },
    {
      "acceptanceCriteria": [
        "Create src/checkpoint/mod.rs with module exports",
        "Define Checkpoint struct with version, created_at, current_story, pause_reason, uncommitted_files",
        "Define StoryCheckpoint with story_id, iteration, max_iterations",
        "Define PauseReason enum (UsageLimitExceeded, RateLimited, UserRequested, Timeout, Error)",
        "Implement Serialize/Deserialize for all types",
        "Add pub mod checkpoint; to src/lib.rs",
        "Unit tests for serialization roundtrip",
        "Typecheck passes"
      ],
      "description": "As a user, I want execution state saved to checkpoint file so I can resume after interruptions.",
      "id": "US-003",
      "notes": "Uses serde_json for persistence",
      "passes": true,
      "priority": 3,
      "title": "Checkpoint types and save/load functionality"
    },
    {
      "acceptanceCriteria": [
        "Create src/checkpoint/manager.rs",
        "Define CheckpointManager with checkpoint_path field",
        "Implement new() that creates .ralph directory if missing",
        "Implement save() that writes atomically (temp file then rename)",
        "Implement load() that reads and deserializes checkpoint",
        "Implement clear() that removes checkpoint file",
        "Implement exists() to check for checkpoint presence",
        "Implement verify() that validates checkpoint version and data",
        "Handle file not found gracefully in load()",
        "Unit tests for all operations",
        "Typecheck passes"
      ],
      "description": "As a developer, I need a checkpoint manager to coordinate saving and loading execution state atomically.",
      "id": "US-004",
      "notes": "Atomic writes prevent corruption on crash",
      "passes": true,
      "priority": 4,
      "title": "Checkpoint manager with atomic saves"
    },
    {
      "acceptanceCriteria": [
        "Create src/timeout/mod.rs with module exports",
        "Define TimeoutConfig struct with agent_timeout, iteration_timeout, heartbeat_interval, missed_heartbeats_threshold",
        "Default agent_timeout: 600 seconds (10 minutes)",
        "Default iteration_timeout: 900 seconds (15 minutes)",
        "Default heartbeat_interval: 30 seconds",
        "Default missed_heartbeats_threshold: 3",
        "Implement TimeoutConfig::default() with these values",
        "Add pub mod timeout; to src/lib.rs",
        "Unit tests for config defaults",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need to timeout agent execution that exceeds time limits.",
      "id": "US-005",
      "notes": "Configurable via CLI flags",
      "passes": true,
      "priority": 5,
      "title": "Timeout configuration and wrapper"
    },
    {
      "acceptanceCriteria": [
        "Create src/timeout/heartbeat.rs",
        "Define HeartbeatMonitor struct with config, last_heartbeat, sender/receiver channels",
        "Implement new() that initializes monitor with TimeoutConfig",
        "Implement pulse() that updates last_heartbeat timestamp",
        "Implement start_monitoring() that spawns background task",
        "Background task checks elapsed time since last heartbeat",
        "Send warning after missed_heartbeats_threshold - 1 missed beats",
        "Send stall detection after missed_heartbeats_threshold missed beats",
        "Implement stop() that terminates background task",
        "Unit tests for heartbeat detection",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need to detect stalled agents via heartbeat monitoring.",
      "id": "US-006",
      "notes": "Uses tokio::sync::watch for signaling",
      "passes": true,
      "priority": 6,
      "title": "Heartbeat monitor for stall detection"
    },
    {
      "acceptanceCriteria": [
        "Create src/pause/mod.rs with module exports",
        "Define RetryStrategy struct with base_delay, max_delay, max_attempts, jitter_percent",
        "Implement calculate_delay() with exponential backoff formula",
        "Default base_delay: 1 second, max_delay: 60 seconds, jitter: 10%",
        "Implement should_retry() based on attempt count and error category",
        "Only retry Transient category errors",
        "Add pub mod pause; to src/lib.rs",
        "Unit tests for delay calculation and retry logic",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need to retry transient errors with exponential backoff.",
      "id": "US-007",
      "notes": "Jitter prevents thundering herd",
      "passes": true,
      "priority": 7,
      "title": "Retry strategy with exponential backoff"
    },
    {
      "acceptanceCriteria": [
        "Add PauseController struct to src/pause/mod.rs",
        "Define PauseState enum (Running, PauseRequested, Paused)",
        "Implement request_pause() that sets PauseRequested state",
        "Implement is_pause_requested() to check for pending pause",
        "Implement execute_pause() that transitions to Paused",
        "Implement resume() that transitions back to Running",
        "Use Arc<RwLock<PauseState>> for thread-safe access",
        "Unit tests for state transitions",
        "Typecheck passes"
      ],
      "description": "As a user, I want to manually pause execution and resume later.",
      "id": "US-008",
      "notes": "Pause happens between iterations, not mid-execution",
      "passes": true,
      "priority": 8,
      "title": "Pause controller for pause/resume state"
    },
    {
      "acceptanceCriteria": [
        "Create src/notification/mod.rs with module exports",
        "Define Notification enum (RateLimited, UsageLimitExceeded, Timeout, Retrying, Paused, Resuming)",
        "Each variant includes relevant data (countdown, attempt, reason)",
        "Add pub mod notification; to src/lib.rs",
        "Typecheck passes"
      ],
      "description": "As a user, I want clear notifications about errors and recovery actions.",
      "id": "US-009",
      "notes": "Notifications displayed via RalphDisplay",
      "passes": true,
      "priority": 9,
      "title": "Notification types and renderer"
    },
    {
      "acceptanceCriteria": [
        "Create src/notification/renderer.rs",
        "Define NotificationRenderer with reference to RalphDisplay",
        "Implement render_rate_limit() with countdown timer display",
        "Implement render_usage_limit() with action required message",
        "Implement render_timeout() with checkpoint confirmation",
        "Implement render_retry() with attempt number and delay",
        "Implement render_paused() with resume instructions",
        "Use existing color scheme from src/ui/colors.rs",
        "Typecheck passes"
      ],
      "description": "As a user, I want themed notification panels for different error states.",
      "id": "US-010",
      "notes": "Reuses existing RalphDisplay and color utilities",
      "passes": true,
      "priority": 10,
      "title": "Notification renderer with themed panels"
    },
    {
      "acceptanceCriteria": [
        "Add Paused variant to ExecutionState in src/mcp/server.rs",
        "Paused includes story_id, paused_at, pause_reason",
        "Add WaitingForRetry variant to ExecutionState",
        "WaitingForRetry includes story_id, retry_at, attempt, max_attempts",
        "Update GetStatusResponse to handle new states",
        "Update state_description() for new states",
        "Update display.update_from_state() for new states",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need new execution states to represent pause and retry conditions.",
      "id": "US-011",
      "notes": "Minimal changes to existing state machine",
      "passes": true,
      "priority": 11,
      "title": "Extend ExecutionState with Paused and WaitingForRetry"
    },
    {
      "acceptanceCriteria": [
        "Add --resume flag to run command in main.rs",
        "Add --no-resume flag to skip checkpoint prompt",
        "Add --timeout <seconds> flag for agent timeout override",
        "Add --no-checkpoint flag to disable checkpointing",
        "Update run command help text",
        "Parse flags and pass to runner",
        "Typecheck passes"
      ],
      "description": "As a user, I want CLI flags to control resume and timeout behavior.",
      "id": "US-012",
      "notes": "Follow existing CLI patterns in main.rs",
      "passes": true,
      "priority": 12,
      "title": "Add --resume and --timeout CLI flags"
    },
    {
      "acceptanceCriteria": [
        "Add 'status' subcommand to CLI in main.rs",
        "Display current/last execution state",
        "Display checkpoint info if present (story, iteration, pause reason, age)",
        "Display suggested action based on state",
        "Exit code 0 for idle, 1 for failed, 75 for paused",
        "Typecheck passes"
      ],
      "description": "As a user, I want a status command to check execution state without starting a run.",
      "id": "US-013",
      "notes": "Exit code 75 = EX_TEMPFAIL for temporary failure",
      "passes": true,
      "priority": 13,
      "title": "Add ralph status command"
    },
    {
      "acceptanceCriteria": [
        "Update runner.rs to accept CheckpointManager",
        "Save checkpoint before each iteration starts",
        "Save checkpoint after quality gates complete",
        "Save checkpoint on any pause or error condition",
        "Clear checkpoint on successful story completion",
        "Typecheck passes"
      ],
      "description": "As a user, I want checkpoints saved automatically during execution.",
      "id": "US-014",
      "notes": "Checkpoint saved at safe points only",
      "passes": true,
      "priority": 14,
      "title": "Integrate checkpoint save into runner loop"
    },
    {
      "acceptanceCriteria": [
        "Check for checkpoint in .ralph/checkpoint.json on run command",
        "Display checkpoint summary (story, iteration, reason, age)",
        "Prompt user: Resume / Discard / View details",
        "If --resume flag, auto-resume without prompt",
        "If --no-resume flag, discard without prompt",
        "Resume sets execution to continue from checkpoint iteration",
        "Typecheck passes"
      ],
      "description": "As a user, I want Ralph to prompt for resume when checkpoint exists.",
      "id": "US-015",
      "notes": "Interactive prompt using dialoguer or similar",
      "passes": true,
      "priority": 15,
      "title": "Integrate checkpoint resume into runner startup"
    },
    {
      "acceptanceCriteria": [
        "Update StoryExecutor in src/mcp/tools/executor.rs",
        "Accept TimeoutConfig in ExecutorConfig",
        "Wrap execute_agent() with tokio::time::timeout()",
        "On timeout, save checkpoint before returning error",
        "Classify timeout as ErrorCategory::Timeout",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need agent execution wrapped with timeout.",
      "id": "US-016",
      "notes": "Hard timeout prevents infinite hangs",
      "passes": true,
      "priority": 16,
      "title": "Integrate timeout wrapper into agent executor"
    },
    {
      "acceptanceCriteria": [
        "Start HeartbeatMonitor before agent execution",
        "Update heartbeat on agent output/activity",
        "On stall warning, log warning message",
        "On stall detection, trigger graceful timeout",
        "Stop monitor after execution completes",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need heartbeat monitoring during agent execution.",
      "id": "US-017",
      "notes": "Stall detection is softer than hard timeout",
      "passes": true,
      "priority": 17,
      "title": "Integrate heartbeat monitor into agent executor"
    },
    {
      "acceptanceCriteria": [
        "After agent execution, classify any error using ErrorDetector",
        "For Transient errors, apply retry strategy",
        "For UsageLimit errors, save checkpoint and pause",
        "For Fatal errors, stop execution with clear message",
        "For Timeout errors, save checkpoint and report",
        "Display appropriate notification for each case",
        "Typecheck passes"
      ],
      "description": "As Ralph, I need to classify executor errors and determine recovery action.",
      "id": "US-018",
      "notes": "Maps classification to recovery action",
      "passes": true,
      "priority": 18,
      "title": "Integrate error classification into executor result handling"
    },
    {
      "acceptanceCriteria": [
        "Add 'p' key handler in src/ui/keyboard.rs",
        "Call pause_controller.request_pause() on 'p' press",
        "Display 'Pausing after current iteration...' message",
        "Ignore 'p' if already paused or pause requested",
        "Update help display to show 'p' key option",
        "Typecheck passes"
      ],
      "description": "As a user, I want to press 'p' to pause execution.",
      "id": "US-019",
      "notes": "Pause happens at next safe point, not immediately",
      "passes": true,
      "priority": 19,
      "title": "Add pause key handler to keyboard input"
    },
    {
      "acceptanceCriteria": [
        "Create tests/error_recovery_tests.rs",
        "Test checkpoint save and load roundtrip",
        "Test error classification for known patterns",
        "Test retry backoff calculation",
        "Test pause controller state transitions",
        "Test timeout wrapper behavior",
        "All tests pass"
      ],
      "description": "As a developer, I need integration tests to verify the recovery system works end-to-end.",
      "id": "US-020",
      "notes": "Uses tests/ directory for integration tests",
      "passes": true,
      "priority": 20,
      "title": "Integration tests for error recovery system"
    }
  ]
}